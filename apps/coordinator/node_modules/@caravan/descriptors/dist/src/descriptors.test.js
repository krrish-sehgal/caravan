var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Network } from '@caravan/bitcoin';
import { decodeDescriptors, encodeDescriptors, getChecksum, getWalletFromDescriptor, } from "./descriptors";
const external = "sh(sortedmulti(2,[f57ec65d/45'/0'/100']xpub6CCHViYn5VzPfSR7baop9FtGcbm3UnqHwa54Z2eNvJnRFCJCdo9HtCYoLJKZCoATMLUowDDA1BMGfQGauY3fDYU3HyMzX4NDkoLYCSkLpbH/0/*,[efa5d916/45'/0'/100']xpub6Ca5CwTgRASgkXbXE5TeddTP9mPCbYHreCpmGt9dhz9y6femstHGCoFESHHKKRcm414xMKnuLjP9LDS7TwaJC9n5gxua6XB1rwPcC6hqDub/0/*))#uxj9xxul";
const internal = "sh(sortedmulti(2,[f57ec65d/45'/0'/100']xpub6CCHViYn5VzPfSR7baop9FtGcbm3UnqHwa54Z2eNvJnRFCJCdo9HtCYoLJKZCoATMLUowDDA1BMGfQGauY3fDYU3HyMzX4NDkoLYCSkLpbH/1/*,[efa5d916/45'/0'/100']xpub6Ca5CwTgRASgkXbXE5TeddTP9mPCbYHreCpmGt9dhz9y6femstHGCoFESHHKKRcm414xMKnuLjP9LDS7TwaJC9n5gxua6XB1rwPcC6hqDub/1/*))#3hxf9z66";
const expectedKeys = [
    {
        xfp: "f57ec65d",
        bip32Path: "m/45'/0'/100'",
        xpub: "xpub6CCHViYn5VzPfSR7baop9FtGcbm3UnqHwa54Z2eNvJnRFCJCdo9HtCYoLJKZCoATMLUowDDA1BMGfQGauY3fDYU3HyMzX4NDkoLYCSkLpbH",
    },
    {
        xfp: "efa5d916",
        bip32Path: "m/45'/0'/100'",
        xpub: "xpub6Ca5CwTgRASgkXbXE5TeddTP9mPCbYHreCpmGt9dhz9y6femstHGCoFESHHKKRcm414xMKnuLjP9LDS7TwaJC9n5gxua6XB1rwPcC6hqDub",
    },
];
const testInternal = "sh(sortedmulti(2,[611d202e/45'/1'/11'/3]tpubDEcXYgwH59QbtaS1q7CNskaL23oXnePHiU5zQuVDTDbSfM2xx5WYKaqgpfKnjAzgrHymmA7rZYmgtLKpugFq4dWJEC6HPpeUrMjFprLx8fW/1/*,[3e191e15/0/0/0/0]tpubDEeGXbhQg9q8ch8RvufnqvK4FPTRxidayvdb4Z24eyGUBSHsEBhQ8jaGZ4acKUzfP3FgVChNEPB47KzMHJbaL2WzvQqijrFTbSUqoHvXuoE/1/*,[96cf6667/45'/1'/12'/2]tpubDEX9s9A6av9oHR89T9VArgrt4zg3zBGndMm6Q2LEaBiEF153K2yF2yewHWmfNicEUdBXzmaP7VBZvT5D3GG1m5cYy36qfsA9RQS1uYw3MGi/1/*))#j8hgkfxv";
const testExternal = "sh(sortedmulti(2,[611d202e/45'/1'/11'/3]tpubDEcXYgwH59QbtaS1q7CNskaL23oXnePHiU5zQuVDTDbSfM2xx5WYKaqgpfKnjAzgrHymmA7rZYmgtLKpugFq4dWJEC6HPpeUrMjFprLx8fW/0/*,[3e191e15/0/0/0/0]tpubDEeGXbhQg9q8ch8RvufnqvK4FPTRxidayvdb4Z24eyGUBSHsEBhQ8jaGZ4acKUzfP3FgVChNEPB47KzMHJbaL2WzvQqijrFTbSUqoHvXuoE/0/*,[96cf6667/45'/1'/12'/2]tpubDEX9s9A6av9oHR89T9VArgrt4zg3zBGndMm6Q2LEaBiEF153K2yF2yewHWmfNicEUdBXzmaP7VBZvT5D3GG1m5cYy36qfsA9RQS1uYw3MGi/0/*))#medls6ae";
const testKeys = [
    {
        xfp: "611d202e",
        bip32Path: "m/45'/1'/11'/3",
        xpub: "tpubDEcXYgwH59QbtaS1q7CNskaL23oXnePHiU5zQuVDTDbSfM2xx5WYKaqgpfKnjAzgrHymmA7rZYmgtLKpugFq4dWJEC6HPpeUrMjFprLx8fW",
    },
    {
        xfp: "3e191e15",
        bip32Path: "m/0/0/0/0",
        xpub: "tpubDEeGXbhQg9q8ch8RvufnqvK4FPTRxidayvdb4Z24eyGUBSHsEBhQ8jaGZ4acKUzfP3FgVChNEPB47KzMHJbaL2WzvQqijrFTbSUqoHvXuoE",
    },
    {
        xfp: "96cf6667",
        bip32Path: "m/45'/1'/12'/2",
        xpub: "tpubDEX9s9A6av9oHR89T9VArgrt4zg3zBGndMm6Q2LEaBiEF153K2yF2yewHWmfNicEUdBXzmaP7VBZvT5D3GG1m5cYy36qfsA9RQS1uYw3MGi",
    },
];
const testConfig = (config) => {
    expect(config.addressType).toEqual("P2SH");
    expect(config.requiredSigners).toEqual(2);
    const derivation1 = config.keyOrigins[0];
    const derivation2 = config.keyOrigins[1];
    expect(derivation1).toStrictEqual(expectedKeys[0]);
    expect(derivation2).toStrictEqual(expectedKeys[1]);
};
describe("decodeDescriptors", () => {
    it("works", () => __awaiter(void 0, void 0, void 0, function* () {
        const config = yield decodeDescriptors(internal, external);
        testConfig(config);
    }));
    it("should throw if called with inconsistent network", () => __awaiter(void 0, void 0, void 0, function* () {
        // Jest's "expect...toThrowError" doesn't work for some reason here
        let passed = false;
        try {
            yield decodeDescriptors(testInternal, testExternal, Network.MAINNET);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (e) {
            if (e instanceof Error) {
                passed = true;
                expect(e.message).toMatch("xpubs do not match expected network");
            }
        }
        expect(passed).toBeTruthy();
        passed = false;
        try {
            yield decodeDescriptors(internal, external, Network.TESTNET);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (e) {
            if (e instanceof Error) {
                passed = true;
                expect(e.message).toMatch("xpubs do not match expected network");
            }
        }
        expect(passed).toBeTruthy();
    }));
});
describe("encodeDescriptors", () => {
    let config;
    beforeEach(() => {
        config = {
            addressType: "P2SH",
            keyOrigins: expectedKeys,
            requiredSigners: 2,
            network: "mainnet",
        };
    });
    it("should convert a config to descriptors", () => __awaiter(void 0, void 0, void 0, function* () {
        const actual = yield encodeDescriptors(config);
        expect(actual.receive).toEqual(external);
        expect(actual.change).toEqual(internal);
    }));
    it("should support test networks", () => __awaiter(void 0, void 0, void 0, function* () {
        for (const network of [Network.TESTNET, Network.REGTEST]) {
            config.network = network;
            config.keyOrigins = testKeys;
            const actual = yield encodeDescriptors(config);
            expect(actual.receive).toEqual(testExternal);
            expect(actual.change).toEqual(testInternal);
        }
    }));
});
describe("getWalletFromDescriptor", () => {
    it("should convert a receive descriptor to a wallet", () => __awaiter(void 0, void 0, void 0, function* () {
        const config = yield getWalletFromDescriptor(external);
        testConfig(config);
    }));
    it("should convert a change descriptor to a wallet", () => __awaiter(void 0, void 0, void 0, function* () {
        const config = yield getWalletFromDescriptor(internal);
        testConfig(config);
    }));
    it("should fail if passed with inconsistent network", () => __awaiter(void 0, void 0, void 0, function* () {
        let passed = false;
        try {
            yield getWalletFromDescriptor(internal, Network.TESTNET);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (e) {
            if (e instanceof Error) {
                passed = true;
                expect(e.message).toMatch("xpubs do not match expected network");
            }
        }
        expect(passed).toBeTruthy();
    }));
});
describe("getChecksum", () => {
    it("should return correct checksum", () => __awaiter(void 0, void 0, void 0, function* () {
        const internalChecksum = yield getChecksum(internal);
        expect(internalChecksum).toEqual("3hxf9z66");
        const externalChecksum = yield getChecksum(external);
        expect(externalChecksum).toEqual("uxj9xxul");
    }));
    it("should throw if invalid or missing checksum", () => __awaiter(void 0, void 0, void 0, function* () {
        let passed = false;
        const invalids = [
            internal.split("#")[0],
            internal.concat("asdf"),
            internal.split("#")[0].concat("#123"),
            internal.split("#")[0].concat("#1234abcd"),
        ];
        for (const test of invalids) {
            try {
                yield getChecksum(test);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            catch (e) {
                if (e instanceof Error) {
                    passed = true;
                }
            }
            expect(passed).toBeTruthy();
        }
    }));
});
